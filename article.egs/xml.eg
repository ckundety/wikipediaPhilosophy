<page><title>XML</title><id>34138</id><revision><id>439610462</id><timestamp>2011-07-15T12:23:34Z</timestamp><contributor><username>ScottyBerg</username><id>11459459</id></contributor><minor /><comment>Reverted edits by [[Special:Contributions/223.29.201.6|223.29.201.6]] ([[User talk:223.29.201.6|talk]]) to last revision by CyberSkull ([[WP:HG|HG]])</comment><text xml:space="preserve">&lt;!--Warning to AutoWikiBrowser users: do not attempt to Unicodify this page as many of the &amp;# notations are in context and should not be converted to their glyph representations.Don't change &quot;Extensible&quot; to &quot;eXtensible&quot;! See http://www.xml.com/axml/notes/TheCorrectTitle.html from the Annotated XML Specification.Elements not tags! For instance, &lt;!ELEMENT&gt; vs &lt;!TAG&gt;.--&gt;{{stack|{{Infobox file format| icon =| logo =| screenshot = [[Image:XML.svg|200px]]| extension = .xml| mime = application/xml,&lt;ref&gt;{{cite web |url=http://tools.ietf.org/html/rfc3023#section-3.2 |title=XML Media Types, RFC 3023 |pages=9–11 |publisher=IETF |date=2001-01 |accessdate=2010-01-04}}&lt;/ref&gt; text/xml&lt;ref&gt;{{cite web |url=http://tools.ietf.org/html/rfc3023#section-3.1 |title=XML Media Types, RFC 3023 |pages=7–9 |publisher=IETF |date=2001-01 |accessdate=2010-01-04}}&lt;/ref&gt; (deprecated in an expired draft)&lt;ref&gt;{{cite web |url=http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03 |title=Internet Drafts: XML Media Types |publisher=IETF |date=2009-09-24 |accessdate=2010-06-10 |author=M. Murata, D. Kohn, and C. Lilley}}&lt;/ref&gt;| type code =| uniform type = public.xml| conforms to = public.text| magic =| owner = [[World Wide Web Consortium]]| genre = [[Markup language]]| container for =| contained by =| extended from = [[Standard Generalized Markup Language|SGML]]| extended to = [[List of XML markup languages|Numerous]], including:&lt;br /&gt;[[XHTML]], [[RSS]], [[Atom (standard)|Atom]], [[KML]]| standard = [http://www.w3.org/TR/2008/REC-xml-20081126/ 1.0 (Fifth Edition)] {{release date and age|2008|11|26}}&lt;br&gt;[http://www.w3.org/TR/2006/REC-xml11-20060816/ 1.1 (Second Edition)] {{release date and age|2006|08|16}}| free = Yes}}{{Infobox W3C Standard| title             = Extensible Markup Language (XML)| status            = Published| year_started      = 1996| editors           = Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan| base_standards    =| related_standards = [[XML Schema]]| abbreviation      = XML| domain            = [[Serialization|Data Serialization]]| website           = [http://www.w3.org/TR/rec-xml XML 1.0]}}}}'''Extensible Markup Language''' ('''XML''') is a set of rules for encoding documents in [[machine-readable]] form. It is defined in the XML 1.0 Specification&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/REC-xml |title=XML 1.0 Specification |publisher=W3.org |date= |accessdate=2010-08-22}}&lt;/ref&gt; produced by the [[W3C]], and several other related specifications, all [[gratis]] [[open standard]]s.&lt;ref&gt;{{cite web|title=W3C DOCUMENT LICENSE|url=http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231}}&lt;/ref&gt;The design goals of XML emphasize simplicity, generality, and usability over the [[Internet]].&lt;ref name=&quot;XML Goals&quot;&gt;{{cite web|title=XML 1.0 Origin and Goals|url=http://www.w3.org/TR/REC-xml/#sec-origin-goals|accessdate=July 2009}}&lt;/ref&gt; It is a textual data format with strong support via [[Unicode]] for the languages of the world. Although the design of XML focuses on documents, it is widely used for the representation of arbitrary [[data structures]], for example in [[web service]]s.Many [[application programming interfaces]] (APIs) have been developed that software developers use to process XML data, and several [[XML schema|schema systems]] exist to aid in the definition of XML-based languages.{{As of|2009}}, hundreds of XML-based languages have been developed,&lt;ref name=&quot;Cover pages list&quot;&gt;{{cite web|url=http://xml.coverpages.org/xmlApplications.html|title=XML Applications and Initiatives}}&lt;/ref&gt; including [[RSS]], [[Atom (standard)|Atom]], [[SOAP]], and [[XHTML]]. XML-based formats have become the default for most office-productivity tools, including [[Microsoft Office]] ([[Office Open XML]]), [[OpenOffice.org]] ([[OpenDocument]]), and [[Apple Computer|Apple]]'s [[iWork]].&lt;ref&gt;{{cite web|title=Introduction to iWork Programming Guide. Mac OS X Reference Library|publisher=Apple|url=http://developer.apple.com/mac/library/documentation/AppleApplications/Conceptual/iWork2-0_XML/Chapter01/Introduction.html}}&lt;/ref&gt;==Key terminology==The material in this section is based on the XML Specification.  This is not an exhaustive list of all the constructs which appear in XML; it provides an introduction to the key constructs most often encountered in day-to-day use.;(Unicode) Character: By definition, an XML document is a string of characters.  Almost every legal [[Unicode]] character may appear in an XML document.;Processor and Application: The ''processor'' analyzes the markup and passes structured information to an ''application''.  The specification places requirements on what an XML processor must do and not do, but the application is outside its scope. The processor (as the specification calls it) is often referred to colloquially as an ''XML parser''.;Markup and Content: The characters which make up an XML document are divided into ''markup'' and ''content''. Markup and content may be distinguished by the application of simple syntactic rules.  All strings which constitute markup either begin with the character &quot;&amp;lt;&quot; and end with a &quot;&amp;gt;&quot;, or begin with the character &quot;&amp;amp;&quot; and end with a &quot;;&quot;.  Strings of characters which are not markup are content.;Tag: A markup construct that begins with &quot;&amp;lt;&quot; and ends with &quot;&gt;&quot;.  Tags come in three flavors: ''start-tags'', for example &lt;code&gt;&amp;lt;section&gt;&lt;/code&gt;, ''end-tags'', for example &lt;code&gt;&amp;lt;/section&gt;&lt;/code&gt;, and ''empty-element tags'', for example &lt;code&gt;&amp;lt;line-break&amp;nbsp;/&gt;&lt;/code&gt;.;Element: A logical document component that either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag.  The characters between the start- and end-tags, if any, are the element's ''content'', and may contain markup, including other elements, which are called ''child elements''.  An example of an element is &lt;code&gt;&amp;lt;Greeting&gt;Hello,&amp;nbsp;world.&amp;lt;/Greeting&gt;&lt;/code&gt; (see [[Hello world program|hello world]]). Another is &lt;code&gt;&amp;lt;line-break&amp;nbsp;/&gt;&lt;/code&gt;.;Attribute: A markup construct consisting of a name/value pair that exists within a start-tag or empty-element tag.   In the example (below) the element ''img'' has two attributes, ''src'' and ''alt'': &lt;code&gt;&lt;img&amp;nbsp;src=&quot;madonna.jpg&quot;&amp;nbsp;alt='Foligno&amp;nbsp;Madonna,&amp;nbsp;by&amp;nbsp;Raphael'&amp;nbsp;/&gt;&lt;/code&gt;.  Another example would be &lt;code&gt;&amp;lt;step&amp;nbsp;number=&quot;3&quot;&gt;Connect&amp;nbsp;A&amp;nbsp;to&amp;nbsp;B.&amp;lt;/step&gt;&lt;/code&gt; where the name of the attribute is &quot;number&quot; and the value is &quot;3&quot;.;XML Declaration: XML documents may begin by declaring some information about themselves, as in the following example.&lt;source lang=&quot;xml&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;/source&gt;==Characters and escaping==XML documents consist entirely of characters from the [[Unicode]] repertoire.  Except for a small number of specifically excluded [[control characters]], any character defined by Unicode may appear within the content of an XML document.  The selection of characters that may appear within markup is somewhat more limited but still large.XML includes facilities for identifying the ''encoding'' of the Unicode characters that make up the document, and for expressing characters that, for one reason or another, cannot be used directly.===Valid characters==={{Main|Valid characters in XML}}Unicode code points in the following ranges are valid in XML 1.0 documents:&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/2006/REC-xml-20060816/#charsets |title=Extensible Markup Language (XML) 1.0 (Fourth Edition) |publisher=W3.org |date= |accessdate=2010-08-22}}&lt;/ref&gt;* U+0009, U+000A, U+000D: these are the only C0 controls accepted in XML 1.0;* U+0020–U+D7FF, U+E000–U+FFFD: this excludes ''some'' (not all) non-characters in the [[Basic Multilingual Plane|BMP]] (all surrogates, U+FFFE and U+FFFF are forbidden);* U+10000–U+10FFFF: this includes ''all'' code points in supplementary planes, including non-characters.XML 1.1&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/xml11/#charsets |title=Extensible Markup Language (XML) 1.1 (Second Edition) |publisher=W3.org |date= |accessdate=2010-08-22}}&lt;/ref&gt; extends the set of allowed characters to include all the above, plus the remaining characters in the range U+0001–U+001F. At the same time, however, it restricts the use of C0 and C1 control characters other than U+0009, U+000A, U+000D, and U+0085 by requiring them to be written in escaped form (for example U+0001 must be written as &amp;amp;#x01; or its equivalent). In the case of C1 characters, this restriction is a backwards incompatibility; it was introduced to allow common encoding errors to be detected.The code point U+0000 is the only character that is not permitted in any XML 1.0 or 1.1 document.===Encoding detection===The Unicode character set can be encoded into bytes for storage or transmission in a variety of different ways, called &quot;encodings&quot;.  Unicode itself defines encodings that cover the entire repertoire; well-known ones include [[UTF-8]] and [[UTF-16]].&lt;ref&gt;{{cite web|url=http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF|title=Characters vs. Bytes}}&lt;/ref&gt;  There are many other text encodings that pre-date Unicode, such as [[ASCII]] and [[ISO/IEC 8859]]; their character repertoires in almost every case are subsets of the Unicode character set.XML allows the use of any of the Unicode-defined encodings, and any other encodings whose characters also appear in Unicode. XML also provides a mechanism whereby an XML processor can reliably, without any prior knowledge, determine which encoding is being used.&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/REC-xml/#sec-guessing|title=Autodetection of Character Encodings}}&lt;/ref&gt; Encodings other than UTF-8 and UTF-16 will not necessarily be recognized by every XML parser.===Escaping===XML provides [[Escape sequence|''escape'']] facilities for including characters which are problematic to include directly. For example:* The characters &quot;&amp;lt;&quot; and &quot;&amp;amp;&quot; are key syntax markers and may ''never'' appear in content outside of a [[CDATA]] section.&lt;ref&gt;It is allowed, but not recommended, to use &quot;&amp;lt;&quot; in XML entity values: [http://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue Extensible Markup Language (XML) 1.0 (Fifth Edition): EntityValue definition]&lt;/ref&gt;* Some character encodings support only a subset of Unicode: for example, it is legal to encode an XML document in ASCII, but ASCII lacks code points for Unicode characters such as &quot;é&quot;.* It might not be possible to type the character on the author's machine.* Some characters have [[glyph]]s that cannot be visually distinguished from other characters: examples are non-breaking-space (&lt;code&gt;&amp;amp;#xa0;&lt;/code&gt;) and Cyrillic Capital Letter A (&lt;code&gt;&amp;amp;#x410;&lt;/code&gt;).There are five ''predefined entities'': &lt;code&gt;&amp;amp;lt;&lt;/code&gt; represents &quot;&amp;lt;&quot;, &lt;code&gt;&amp;amp;gt;&lt;/code&gt; represents &quot;&gt;&quot;, &lt;code&gt;&amp;amp;amp;&lt;/code&gt; represents &quot;&amp;amp;&quot;, &lt;code&gt;&amp;amp;apos;&lt;/code&gt; represents ', and &lt;code&gt;&amp;amp;quot;&lt;/code&gt; represents &quot;.  All permitted Unicode characters may be represented with a ''[[numeric character reference]]''.  Consider the Chinese character &quot;中&quot;, whose numeric code in Unicode is hexadecimal 4E2D, or decimal 20,013.  A user whose keyboard offers no method for entering this character could still insert it in an XML document encoded either as &lt;code&gt;&amp;amp;#20013;&lt;/code&gt; or &lt;code&gt;&amp;amp;#x4e2d;&lt;/code&gt;.  Similarly, the string &quot;&lt;code&gt;I &amp;lt;3 Jörg&lt;/code&gt;&quot; could be encoded for inclusion in an XML document as &quot;&lt;code&gt;I &amp;amp;lt;3 J&amp;amp;#xF6;rg&lt;/code&gt;&quot;.&quot;&lt;code&gt;&amp;amp;#0;&lt;/code&gt;&quot; is not permitted, however, as the [[null character]] is one of the control characters excluded from XML, even when using a numeric character reference.&lt;ref&gt;{{cite web|url=http://www.w3.org/International/questions/qa-controls|title=W3C I18N FAQ: HTML, XHTML, XML and Control Codes}}&lt;/ref&gt; An alternative encoding mechanism such as [[Base64]] is needed to represent such characters.===Comments===Comments may appear anywhere in a document outside other markup. Comments cannot appear before the XML declaration. The string &quot;&lt;code&gt;--&lt;/code&gt;&quot; (double-hyphen) is not allowed inside comments.  Comments start with &quot;&amp;lt;!--&quot;.  The ampersand has no special significance within comments, so entity and character references are not recognized as such, and there is no way to represent characters outside the character set of the document encoding.An example of a valid comment:&quot;&lt;code&gt;&amp;lt;!-- no need to escape &amp;lt;code&amp;gt; &amp;amp; such in comments --&amp;gt;&lt;/code&gt;&quot;===International use==={{ChineseText|example}}{{CyrillicText|example}}XML supports the direct use of almost any [[Unicode]] character in element names, attributes, comments, character data, and processing instructions (other than the ones that have special symbolic meaning in XML itself, such as the less-than sign, &quot;&lt;&quot;). Therefore, the following is a well-formed XML document, even though it includes both [[Chinese character|Chinese]] and [[Cyrillic alphabet|Cyrillic]] characters:&lt;source lang=&quot;xml&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;俄语&gt;Китайська мова&lt;/俄语&gt;&lt;/source&gt;==Well-formedness and error-handling=={{main|Well-formed document}}The XML specification defines an XML document as a text that is [[Well-formed element|well-formed]], i.e. it satisfies a list of syntax rules provided in the specification.  The list is fairly lengthy; some key points are:* It contains only properly encoded legal Unicode characters.* None of the special syntax characters such as &quot;&amp;lt;&quot; and &quot;&amp;amp;&quot; appear except when performing their markup-delineation roles.* The begin, end, and empty-element tags that delimit the elements are correctly nested, with none missing and none overlapping.* The element tags are case-sensitive; the beginning and end tags must match exactly. Tag names cannot contain any of the characters &lt;nowiki&gt;!&quot;#$%&amp;'()*+,/;&lt;=&gt;?@[\]^`{|}~&lt;/nowiki&gt;, nor a space character, and cannot start with -, ., or a numeric digit.* There is a single &quot;root&quot; element that contains all the other elements.The definition of an ''XML document'' excludes texts that contain violations of well-formedness rules; they are simply not XML. An XML processor that encounters such a violation is required to report such errors and to cease normal processing. This policy, occasionally referred to as [[Draco (lawgiver)|draconian]], stands in notable contrast to the behavior of programs that process [[HTML]], which are designed to produce a reasonable result even in the presence of severe markup errors. XML's policy in this area has been criticized as a violation of [[Postel's law]].&lt;ref&gt;{{cite web|url=http://diveintomark.org/tag/draconian|title=Articles tagged with &quot;draconian&quot;}}&lt;/ref&gt;&lt;!-- keep for possible reuse'''Tree representation of an XML Document'''The nesting of elements leads directly to a tree representation for an XML document. The root element becomes the root of a tree. Because every element is composed of a sequence of other elements and character data, it is easy to determine the children of each element. Just take each item in the sequence and create a new child node.Here is an example of a structured XML document:&lt;source lang=&quot;xml&quot;&gt;&lt;recipe name=&quot;bread&quot; prep_time=&quot;5 mins&quot; cook_time=&quot;3 hours&quot;&gt;&lt;title&gt;Basic bread&lt;/title&gt;&lt;ingredient amount=&quot;8&quot; unit=&quot;dL&quot;&gt;Flour&lt;/ingredient&gt;&lt;ingredient amount=&quot;10&quot; unit=&quot;grams&quot;&gt;Yeast&lt;/ingredient&gt;&lt;ingredient amount=&quot;4&quot; unit=&quot;dL&quot; state=&quot;warm&quot;&gt;Water&lt;/ingredient&gt;&lt;ingredient amount=&quot;1&quot; unit=&quot;teaspoon&quot;&gt;Salt&lt;/ingredient&gt;&lt;instructions&gt;&lt;step&gt;Mix all ingredients together.&lt;/step&gt;&lt;step&gt;Knead thoroughly.&lt;/step&gt;&lt;step&gt;Cover with a cloth, and leave for one hour in warm room.&lt;/step&gt;&lt;step&gt;Knead again.&lt;/step&gt;&lt;step&gt;Place in a bread baking tin.&lt;/step&gt;&lt;step&gt;Cover with a cloth, and leave for one hour in warm room.&lt;/step&gt;&lt;step&gt;Bake in the oven at 180(degrees)C for 30 minutes.&lt;/step&gt;&lt;/instructions&gt;&lt;/recipe&gt;&lt;/source&gt;&lt;source lang=&quot;xml&quot;&gt;!-- Not well-formed fragment --&lt;title&gt;Book on Logic&lt;author&gt;Aristotle&lt;/title&gt;&lt;/author&gt;&lt;/source&gt;One way of writing the same information in a way which could be incorporated into a well-formed XML document is as follows:&lt;source lang=&quot;xml&quot;&gt;!-- Well-formed XML fragment --&lt;title&gt;Book on Logic&lt;/title&gt; &lt;author&gt;Aristotle&lt;/author&gt;&lt;/source&gt;In XML, the proper way of nesting code is through parallel data and character dataEx.&lt;source lang=&quot;xml&quot;&gt;&lt;paragraph&gt;Hello, my name is&lt;first-name&gt;John&lt;/first-name&gt;&lt;last-name&gt; Doe&lt;/last-name&gt;from the&lt;country&gt;United States&lt;/country&gt;&lt;/paragraph&gt;&lt;/source&gt;This shows the “paragraph” consists of a sequence of five items. The “first-name”, “last-name”, and “country” elements consisted of character data and the other two areas were just character data.===Entity references===An [[SGML entity|entity]] in XML is a named body of data, usually text. Entities are often used to represent single characters that cannot easily be entered on the keyboard; they are also used to represent pieces of standard (&quot;boilerplate&quot;) text that occur in many documents, especially if there is a need to allow such text to be changed in one place only.Special characters can be represented either using  [[SGML entity|entity]] references, or by means of [[numeric character reference]]s. An example of a numeric character reference is &quot;&lt;code&gt;&amp;amp;#x20AC;&lt;/code&gt;&quot;, which refers to the [[Euro symbol]] by means of its [[Unicode]] codepoint in [[hexadecimal]].An entity reference is a [[placeholder]] that represents that entity. It consists of the entity's name preceded by an [[ampersand]] (&quot;&lt;code&gt;&amp;amp;&lt;/code&gt;&quot;) and followed by a [[semicolon]] (&quot;&lt;code&gt;;&lt;/code&gt;&quot;). XML has five [[predeclared]] entities:* &lt;code&gt;&amp;amp;amp;&lt;/code&gt; (&amp; or &quot;ampersand&quot;)* &lt;code&gt;&amp;amp;lt;&lt;/code&gt; (&amp;lt; or &quot;less than&quot;)* &lt;code&gt;&amp;amp;gt;&lt;/code&gt;   (&amp;gt; or &quot;greater than&quot;)* &lt;code&gt;&amp;amp;apos;&lt;/code&gt; (' or &quot;apostrophe&quot;)* &lt;code&gt;&amp;amp;quot;&lt;/code&gt; (&quot; or &quot;quotation mark&quot;)Here is an example using a predeclared XML entity to represent the ampersand in the name &quot;AT&amp;amp;T&quot;:&lt;source lang=&quot;xml&quot;&gt;&lt;company_name&gt;AT&amp;amp;T&lt;/company_name&gt;&lt;/source&gt;Additional entities (beyond the predefined ones) can be declared in the document's [[XML#DTD|Document Type Definition (DTD)]].  A basic example of doing so in a minimal internal DTD follows. Declared entities can describe single characters or pieces of text, and can reference each other.&lt;span class=&quot;source-xml&quot;&gt;&lt;span class=&quot;sc3&quot;&gt;&lt;span class=&quot;re1&quot;&gt;&amp;lt;?xml&lt;/span&gt; &lt;span class=&quot;re0&quot;&gt;version&lt;/span&gt;=&lt;span class=&quot;st0&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;re0&quot;&gt;encoding&lt;/span&gt;=&lt;span class=&quot;st0&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;re2&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;sc0&quot;&gt;&amp;lt;!DOCTYPE example [&lt;/span&gt;&lt;span class=&quot;sc0&quot;&gt;    &amp;lt;!ENTITY copy &quot;&amp;amp;#xA9;&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc0&quot;&gt;    &amp;lt;!ENTITY copyright-notice &quot;Copyright &amp;amp;copy; 2009, XYZ Enterprises&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc0&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc3&quot;&gt;&lt;span class=&quot;re1&quot;&gt;&amp;lt;example&lt;span class=&quot;re2&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;sc1&quot;&gt;    &amp;amp;copyright-notice;&lt;/span&gt;&lt;span class=&quot;sc3&quot;&gt;&lt;span class=&quot;re1&quot;&gt;&amp;lt;/example&lt;span class=&quot;re2&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;When viewed in a suitable browser, the XML document above appears as:{{Quotation|Copyright © 2009, XYZ Enterprises}}====Numeric character references====Numeric character references look like entity references, but instead of a name, they contain the &quot;&lt;code&gt;[[number sign|#]]&lt;/code&gt;&quot; character followed by a number.  The number (in decimal or &quot;&lt;code&gt;x&lt;/code&gt;&quot;-prefixed [[hexadecimal]]) represents a Unicode code point. Unlike entity references, they are neither predeclared nor do they need to be declared in the document's DTD. They have typically been used to represent characters that are not easily encodable, such as an [[Arabic language|Arabic]] character in a document produced on a European computer.  The ampersand in the &quot;AT&amp;amp;T&quot; example could also be [[escape character|escaped]] like this (decimal 38 and hexadecimal 26 both represent the Unicode code point for the &quot;&amp;amp;&quot; character):&lt;source lang=&quot;xml&quot;&gt;&lt;company_name&gt;AT&amp;#38;T&lt;/company_name&gt;&lt;company_name&gt;AT&amp;#x26;T&lt;/company_name&gt;&lt;/source&gt;Similarly, in the previous example, notice that &quot;&amp;amp;#xA9;&quot; is used to generate the “©” symbol.See also [[numeric character reference]]s.===Well-formed documents===In XML, a [[well-formed element|well-formed]] document must conform to the following rules, among others:* Non-empty elements are [[delimiter|delimited]] by both a start-tag and an end-tag.* Empty elements may be marked with an empty-element (self-closing) tag, such as &lt;code&gt;&amp;lt;IAmEmpty&amp;nbsp;/&gt;&lt;/code&gt;. This is equal to &lt;code&gt;&amp;lt;IAmEmpty&amp;gt;&amp;lt;/IAmEmpty&amp;gt;&lt;/code&gt;.* All attribute values are quoted with either single (') or double (&quot;) quotes. Single quotes close a single quote and double quotes close a double quote.&lt;ref&gt;{{cite web|title=XML Attributes|url=http://www.w3schools.com/Xml/xml_attributes.asp|publisher=W3Schools}}&lt;/ref&gt;&lt;ref&gt;{{cite web|title=Attributes [XML Standards]|url=http://msdn.microsoft.com/en-us/library/ms256152(VS.85).aspx|publisher=Microsoft}}&lt;/ref&gt;* To include a double quote inside an attribute value that is double quoted, or a single quote inside an attribute value that is single quoted, escape the inner quote mark using [[#Entity references|entity references]].* Tags may be nested but must not overlap. Each non-root element must be completely contained in another element.* The document complies with its declared character encoding. The encoding may be declared or implied externally, such as in &quot;Content-Type&quot; headers when a document is transported via [[Hypertext Transfer Protocol|HTTP]], or internally, using explicit markup at the very beginning of the document. When no such declaration exists, a Unicode encoding is assumed, as defined by a Unicode [[Byte-order mark|Byte Order Mark]] before the document's first character. If the mark does not exist, UTF-8 encoding is assumed.Element names are case-sensitive. For example, the following is a well-formed matching pair::&lt;code&gt;&amp;lt;Step&gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;/Step&gt;&lt;/code&gt;whereas these are not:&lt;code&gt;&amp;lt;Step&gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;/step&gt;&lt;/code&gt;:&lt;code&gt;&amp;lt;STEP&gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;/step&gt;&lt;/code&gt;By carefully choosing the names of the XML elements one may convey the meaning of the data in the [[Markup language|markup]]. This increases human readability while retaining the rigor needed for software parsing.Choosing meaningful names implies the [[semantics]] of elements and attributes to a human reader without reference to external documentation. However, this can lead to verbosity, which complicates [[authoring]] and increases [[file size]].===Automatic verification===It is relatively simple to verify that a document is well-formed or validated XML, because the rules of well-formedness and validation of XML are designed for portability of tools. The idea is that any tool designed to work with XML files will be able to work with XML files written in any XML language (or XML application). Here are some examples of ways to verify XML documents:* load it into an XML-capable browser, such as [[Mozilla Firefox|Firefox]] or [[Internet Explorer]]* use a tool like xmlwf (usually bundled with [[Expat (XML)|expat]])* parse the document, for instance in [[Ruby programming language|Ruby]]:&lt;source lang=&quot;ruby&quot;&gt;irb&gt; require &quot;rexml/document&quot;irb&gt; include REXMLirb&gt; doc = Document.new(File.new(&quot;test.xml&quot;)).root&lt;/source&gt;--&gt;==Schemas and validation==In addition to being well-formed, an XML document may be ''valid''.  This means that it contains a reference to a [[Document Type Definition|Document Type Definition (DTD)]], and that its elements and attributes are declared in that DTD and follow the grammatical rules for them that the DTD specifies.XML processors are classified as ''validating'' or ''non-validating'' depending on whether or not they check XML documents for validity.  A processor that discovers a validity error must be able to report it, but may continue normal processing.A DTD is an example of a ''[[XML schema|schema]]'' or ''grammar''.  Since the initial publication of XML 1.0, there has been substantial work in the area of schema languages for XML. Such schema languages typically constrain the set of elements that may be used in a document, which attributes may be applied to them, the order in which they may appear, and the allowable parent/child relationships.===DTD==={{Main|Document Type Definition}}The oldest schema language for XML is the [[Document Type Definition]] (DTD), inherited from [[SGML]].DTDs have the following benefits:* DTD support is ubiquitous due to its inclusion in the XML 1.0 standard.* DTDs are terse compared to element-based schema languages and consequently present more information in a single screen.* DTDs allow the declaration of [[SGML entity|standard public entity sets]] for publishing characters.* DTDs define a ''document type'' rather than the types used by a namespace, thus grouping all constraints for a document in a single collection.DTDs have the following limitations:* They have no explicit support for newer [[feature (software design)|feature]]s of XML, most importantly [[XML Namespace|namespaces]].* They lack expressiveness. XML DTDs are simpler than SGML DTDs and there are certain structures that cannot be expressed with regular grammars. DTDs only support rudimentary datatypes.* They lack readability. DTD designers typically make heavy use of parameter entities (which behave essentially as textual [[macro (computer science)|macros]]), which make it easier to define complex grammars, but at the expense of clarity.* They use a syntax based on [[regular expression]] syntax, inherited from [[SGML]], to describe the schema. Typical XML APIs such as [[Simple API for XML|SAX]] do not attempt to offer applications a structured representation of the syntax, so it is less accessible to programmers than an element-based syntax may be.Two peculiar features that distinguish DTDs from other schema types are the syntactic support for embedding a DTD within XML documents and for defining ''entities'', which are arbitrary fragments of text and/or markup that the XML processor inserts in the DTD itself and in the XML document wherever they are referenced, like character escapes.DTD technology is still used in many applications because of its ubiquity.===XML Schema==={{Main|XML Schema (W3C)}}A newer [[XML schema|schema]] language, described by the W3C as the successor of DTDs, is [[XML Schema (W3C)|XML Schema]], often referred to by the [[acronym and initialism|initialism]] for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich [[datatype|datatyping]] system and allow for more detailed constraints on an XML document's logical structure. XSDs also use an XML-based format, which makes it possible to use ordinary XML tools to help process them.===RELAX NG==={{Main|RELAX NG}}[[RELAX NG]] was initially specified by [[OASIS (organization)|OASIS]] and is now also an ISO international standard (as part of [[DSDL]]). RELAX NG schemas may be written in either an XML based syntax or a more compact non-XML syntax; the two syntaxes are [[isomorphic]] and  [[James Clark (programmer)|James Clark]]'s [[Trang conversion tool]] can convert between them without loss of information. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use [[datatype]] framework  [[Plug-in (computing)|plug-in]]s; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.===Schematron==={{Main|Schematron}}[[Schematron]] is a language for making [[Assertion (computing)|assertions]] about the presence or absence of patterns in an XML document. It typically uses [[XPath]] expressions.===ISO DSDL and other schema languages===The ISO [[DSDL]] (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes [[RELAX NG]] full and compact syntax, [[Schematron]] assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based [[routing]] of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for [[publishing]].Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide the [[infoset]] augmentation facility and attribute defaults. RELAX NG and Schematron intentionally do not provide these.==Related specifications==A cluster of specifications closely related to XML have been developed, starting soon after the initial publication of XML 1.0.  It is frequently the case that the term &quot;XML&quot; is used to refer to XML together with one or more of these other technologies which have come to be seen as part of the XML core.*[[XML Namespace]]s enable the same document to contain XML elements and attributes taken from different vocabularies, without any [[naming collision]]s occurring.  Although XML Namespaces are not part of the XML specification itself, virtually all XML software also supports XML Namespaces.* [[XML Base]] defines the &lt;code&gt;xml:base&lt;/code&gt; attribute, which may be used to set the base for resolution of relative URI references within the scope of a single XML element.* The [[XML Information Set]] or ''XML infoset'' describes an abstract data model for XML documents in terms of ''information items''.  The infoset is commonly used in the specifications of XML languages, for convenience in describing constraints on the XML constructs those languages allow.*xml:id Version 1.0 asserts that an attribute named &lt;code&gt;xml:id&lt;/code&gt; functions as an &quot;ID attribute&quot; in the sense used in a DTD.* [[XPath]] defines a syntax named ''XPath expressions'' which identifies one or more of the internal components (elements, attributes, and so on) included in an XML document.  XPath is widely used in other core-XML specifications and in programming libraries for accessing XML-encoded data.* [[XSLT]] is a language with an XML-based syntax that is used to transform XML documents into other XML documents, HTML, or other, unstructured formats such as plain text or RTF. XSLT is very tightly coupled with XPath, which it uses to address components of the input XML document, mainly elements and attributes.* [[XSL Formatting Objects]], or XSL-FO, is a markup language for XML document formatting which is most often used to generate [[PDF]]s.*[[XQuery]] is an XML-oriented query language strongly rooted in XPath and XML Schema.  It provides methods to access, manipulate and return XML, and is mainly conceived as a query language for [[XML database]]s.*[[XML Signature]] defines syntax and processing rules for creating [[digital signatures]] on XML content.*[[XML Encryption]] defines syntax and processing rules for [[encryption|encrypting]] XML content. &lt;!--* [[XPointer]] is a system for addressing components of XML-based internet media. --&gt;Some other specifications conceived as part of the &quot;XML Core&quot; have failed to find wide adoption, including [[XInclude]], [[XLink]], and [[XPointer]].==Use on the Internet==It is common for XML to be used in interchanging data over the Internet.  RFC 3023 gives rules for the construction of [[Internet media type|Internet Media Types]] for use when sending XML.  It also defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data is in XML, and nothing about its [[semantics]].  The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems and is now in the process of being deprecated.&lt;ref&gt;{{cite web|url=http://tools.ietf.org/html/draft-murata-kohn-lilley-xml-03 |title=Internet Drafts: XML Media Types |publisher=IETF |date=2009-09-24 |accessdate=2010-06-10|author=M. Murata, D. Kohn, and C. Lilley}}&lt;/ref&gt; RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/svg+xml&quot; for [[SVG]].Further guidelines for the use of XML in a networked context may be found in [http://www.ietf.org/rfc/rfc3470.txt RFC 3470], also known as IETF BCP 70; this document is very wide-ranging and covers many aspects of designing and deploying an XML-based language.==Programming interfaces==The design goals of XML include &quot;It shall be easy to write programs which process XML documents.&quot;&lt;ref name=&quot;XML Goals&quot; /&gt; Despite this fact, the XML specification contains almost no information about how programmers might go about doing such processing.  The [[XML Infoset]] provides a vocabulary to refer to the constructs within an XML document, but once again does not provide any guidance on how to access this information.  A variety of [[API]]s for accessing XML have been developed and used, and some have been standardized.Existing APIs for XML processing tend to fall into these categories:* Stream-oriented APIs accessible from a programming language, for example [[Simple API for XML|SAX]] and [[StAX]].* Tree-traversal APIs accessible from a programming language, for example [[DOM (XML API)|DOM]].* [[XML data binding]], which provides an automated translation between an XML document and programming-language objects.* Declarative transformation languages such as [[XSLT]] and [[XQuery]].Stream-oriented facilities require less memory and, for certain tasks which are based on a linear traversal of an XML document, are faster and simpler than other alternatives.  Tree-traversal and data-binding APIs typically require the use of much more memory, but are often found more convenient for use by programmers; some include declarative retrieval of document components via the use of XPath expressions.XSLT is designed for declarative description of XML document transformations, and has been widely implemented both in server-side packages and Web browsers. XQuery overlaps XSLT in its functionality, but is designed more for searching of large [[XML database]]s.===Simple API for XML (SAX)===[[Simple API for XML|SAX]] is a [[lexical analysis|lexical]], [[Event-driven programming|event-driven]] interface in which a document is read serially and its contents are reported as [[callback (computer science)|callback]]s to various [[method (computer science)|method]]s on a [[event handler|handler object]] of the user's design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.===Pull parsing===Pull parsing&lt;ref&gt;[http://www.xml.com/pub/a/2005/07/06/tr.html Push, Pull, Next!] by Bob DuCharme, at XML.com&lt;/ref&gt; treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of [[recursive descent parser|recursive-descent parsers]] in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods.  Examples of pull parsers include [[StAX]] in the [[Java (programming language)|Java]] programming language, XMLReader in [[PHP]] and System.Xml.XmlReader in the [[.NET Framework]].A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this iterator can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, [[XML namespace|namespace]], values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code..===Document Object Model (DOM)===[[Document Object Model|DOM]] (Document Object Model) is an [[User interface|interface]]-oriented [[Application Programming Interface]] that allows for navigation of the entire document as if it were a tree of &quot;[[Node (computer science)|Node]]&quot; [[Object (computer science)|object]]s representing the document's contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM Nodes are abstract; implementations provide their own [[programming]] language-specific [[language binding|bindings]]. DOM implementations tend to be [[memory]] intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.===Data binding===Another form of XML processing API is [[XML data binding]], where XML data is made available as a hierarchy of custom, strongly typed classes, in contrast to the generic objects created by a [[Document Object Model]] parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the [[Java Architecture for XML Binding]] (JAXB) and XML Serialization in .NET.&lt;ref&gt;{{cite web|url=http://msdn.microsoft.com/en-us/library/ms950721.aspx |title=XML Serialization in the .NET Framework |publisher=Msdn.microsoft.com |date= |accessdate=2009-07-31}}&lt;/ref&gt;===XML as data type===XML is beginning to appear as a first-class data type in other languages. The [[E4X|ECMAScript for XML]] (E4X) extension to the [[ECMAScript]]/JavaScript language explicitly defines two specific objects (XML and XMLList) for JavaScript, which support XML document nodes and XML node lists as distinct objects and use a dot-notation specifying parent-child relationships.&lt;ref&gt;{{cite web|title=Processing XML with E4X|url=https://developer.mozilla.org/en/core_javascript_1.5_guide/processing_xml_with_e4x|work=Mozilla Developer Center|publisher=Mozilla Foundation}}&lt;/ref&gt; E4X is supported by the [[Mozilla]] 2.5+ browsers and Adobe [[Actionscript]], but has not been adopted more universally. Similar notations are used in Microsoft's [[LINQ]] implementation for Microsoft .NET 3.5 and above, and in [[Scala (programming language)|Scala]] (which uses the Java VM). The open-source xmlsh application, which provides a Linux-like shell with special features for XML manipulation, similarly treats XML as a data type, using the &lt;[ ]&gt; notation.&lt;ref&gt;{{cite web|url=http://www.xmlsh.org/CoreSyntax |title=XML Shell: Core Syntax |publisher=xmlsh |date=2010-05-13 |accessdate=2010-08-22}}&lt;/ref&gt; The [[Resource Description Framework]] defines a data type &lt;code&gt;rdf:XMLLiteral&lt;/code&gt; to hold wrapped, [[canonical XML]].&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#dfn-rdf-XMLLiteral |title=Resource Description Framework (RDF): Concepts and Abstract Syntax |publisher=W3.org |date= |accessdate=2010-08-22}}&lt;/ref&gt;==History==XML is an application profile of [[SGML]] (ISO 8879).&lt;ref name=&quot;iso19757-3_xmlref&quot;&gt;{{Cite document | title= ISO/IEC 19757-3 | page= vi | publisher= [[ISO]]/[[IEC]] | date= 1 June 2006 | postscript= &lt;!--None--&gt; }}&lt;/ref&gt;The versatility of [[SGML]] for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.&lt;ref name=OED&gt;{{cite web | title=A conversation with Tim Bray: Searching for ways to tame the world's vast stores of information | url=http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282 | first=Tim |last=Bray | month=February | year=2005 | publisher=Association for Computing Machinery's &quot;Queue site&quot; | accessdate=April 16, 2006 }}&lt;/ref&gt;&lt;ref name=multimedia&gt;{{cite book | title=Interactive multimedia | chapter=Publishers, multimedia, and interactivity | publisher= Cobb Group | isbn=1-55615-124-1 | year=1988 | author=edited by Sueann Ambron and Kristina Hooper ; foreword by John Sculley.}}&lt;/ref&gt; By the mid-1990s some practitioners of SGML had gained experience with the then-new [[World Wide Web]], and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew.  [[Dan Connolly]] added SGML to the list of W3C's activities when he joined the staff in 1995; work began in mid-1996 when Sun Microsystems engineer [[Jon Bosak]] developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.&lt;ref name=drmacro&gt;{{cite web| title=XML is 10| url=http://drmacros-xml-rants.blogspot.com/#116460437782808906| year=2006| author=Eliot Kimber}}&lt;/ref&gt;XML was compiled by a [[working group]] of eleven members,&lt;ref&gt;The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210.&lt;/ref&gt; supported by an (approximately) 150-member Interest Group.  Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by [[Michael Sperberg-McQueen]] on December 4, 1997.&lt;ref&gt;{{cite web|url=http://www.w3.org/XML/9712-reports.html |title=Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG |publisher=W3.org |date= |accessdate=2009-07-31}}&lt;/ref&gt; [[James Clark (XML expert)|James Clark]] served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty&amp;nbsp;/&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally [[Tim Bray]] and [[Michael Sperberg-McQueen]].  Halfway through the project Bray accepted a consulting engagement with [[Netscape Communications Corporation|Netscape]], provoking vociferous protests from Microsoft.  Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft's [[Jean Paoli]] as a third co-editor.The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences.  The major design decisions were reached in twenty weeks of intense work between July and November 1996, when the first Working Draft of an XML specification was published.&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/WD-xml-961114.html |title=Extensible Markup Language (XML) |publisher=W3.org |date=1996-11-14 |accessdate=2009-07-31}}&lt;/ref&gt;  Further design work continued through 1997, and XML 1.0 became a [[W3C]] Recommendation on February 10, 1998.===Sources==='''XML''' is a profile of an ISO standard [[SGML]], and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation ([[processing instruction]]s), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts [[Unicode]] as the document [[Character encoding|character set]]).Other sources of technology for XML were the [[Text Encoding Initiative]] (TEI), which defined a profile of SGML for use as a &quot;transfer syntax&quot;; and [[HTML]], in which elements were synchronous with their resource, document character sets were separate from resource encoding, the xml:lang attribute was invented, and (like [[HTTP]]) metadata accompanied the resource rather than being needed at the declaration of a link.  The Extended Reference Concrete Syntax (ERCS) project of the SPREAD (Standardization Project Regarding East Asian Documents) project of the ISO-related China/Japan/Korea Document Processing expert group was the basis of XML 1.0's naming rules; SPREAD also introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. To support ERCS, XML and HTML better, the SGML standard IS 8879 was revised in 1996 and 1998 with WebSGML Adaptations. The XML header followed that of ISO [[HyTime]].Ideas that developed during discussion which were novel in XML included the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags. The notion of well-formedness as opposed to validity (which enables parsing without a schema) was first formalized in XML, although it had been implemented successfully in the Electronic Book Technology &quot;Dynatext&quot; software;&lt;ref&gt;{{cite web|author=Jon Bosak, Sun Microsystems |url=http://2006.xmlconference.org/proceedings/162/presentation.html |title=Closing Keynote, XML 2006 |publisher=2006.xmlconference.org |date=2006-12-07 |accessdate=2009-07-31}}&lt;/ref&gt; the software from the University of Waterloo New Oxford English Dictionary Project; the RISP LISP SGML text processor at Uniscope, Tokyo; the US Army Missile Command IADS hypertext system; Mentor Graphics Context; Interleaf and Xerox Publishing System.===Versions===There are two current versions of XML. The first (''XML 1.0'') was initially defined in 1998. It has undergone minor revisions since then, without being given a new version number, and is currently in its fifth edition, as published on November 26, 2008. It is widely implemented and still recommended for general use.The second (''XML 1.1'') was initially published on February 4, 2004, the same day as XML 1.0 Third Edition,&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/2004/REC-xml-20040204 |title=Extensible Markup Language (XML) 1.0 (Third Edition) |publisher=W3.org |date= |accessdate=2010-08-22}}&lt;/ref&gt; and is currently in its second edition, as published on August 16, 2006. It contains features (some contentious) that are intended to make XML easier to use in certain cases.&lt;ref name=&quot;xml11rationale&quot;&gt;{{cite web|url=http://www.w3.org/TR/xml11/#dt-name|title=Extensible Markup Language (XML) 1.1 (Second Edition)&amp;nbsp;– Rationale and list of changes for XML 1.1|accessdate=2009-12-11|publisher=W3C}}&lt;/ref&gt; The main changes are to enable the use of line-ending characters used on [[EBCDIC]] platforms, and the use of scripts and characters absent from Unicode 3.2. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features.&lt;ref&gt;{{cite book| last = Harold| first = Elliotte Rusty| title = Effective XML| publisher = Addison-Wesley| year = 2004| pages = 10–19| url = http://www.cafeconleche.org/books/effectivexml/| isbn = 0321150406}}&lt;/ref&gt;Prior to its fifth edition release, XML 1.0 differed from XML 1.1 in having stricter requirements for characters available for use in element and attribute names and unique identifiers: in the first four editions of XML 1.0 the characters were exclusively enumerated using a specific version of the [[Unicode]] standard (Unicode 2.0 to Unicode 3.2.) The fifth edition substitutes the mechanism of XML 1.1, which is more future-proof but reduces [[Redundancy (information theory)|redundancy]]. The approach taken in the fifth edition of XML 1.0 and in all editions of XML 1.1 is that only certain characters are forbidden in names, and everything else is allowed, in order to accommodate the use of suitable name characters in future versions of Unicode. In the fifth edition, XML names may contain characters in the [[Balinese script|Balinese]], [[Cham script|Cham]], or [[Phoenician alphabet|Phoenician]] scripts among many others which have been added to Unicode since Unicode 3.2.&lt;ref name=&quot;xml11rationale&quot; /&gt;Almost any Unicode code point can be used in the character data and attribute values of an XML 1.0 or 1.1 document, even if the character corresponding to the code point is not defined in the current version of Unicode. In character data and attribute values, XML 1.1 allows the use of more [[control character]]s than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references (and #x7F through #x9F, which had been allowed in XML 1.0, are in XML 1.1 even required to be expressed as numeric character references&lt;ref&gt;{{cite web|url=http://www.w3.org/TR/xml11/#sec-xml11 |title=Extensible Markup Language (XML) 1.1 (Second Edition) |publisher=W3.org |date= |accessdate=2010-08-22}}&lt;/ref&gt;). Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.There has been discussion of an XML 2.0, although no organization has announced plans for work on such a project. XML-SW (SW for [[Skunkworks project|skunkworks]]), written by one of the original developers of XML,&lt;ref&gt;Tim Bray: ''[http://www.textuality.com/xml/xmlSW.html Extensible Markup Language - SW (XML-SW)].'' 2002-02-10&lt;/ref&gt; contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of [[XML namespace|namespace]]s, [[XML Base]] and [[XML Information Set]] (''infoset'') into the base standard.The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset.  The working group is not chartered to produce any official standards.  Since XML is by definition text-based, ITU-T and ISO are using the name ''[[Fast Infoset]]'' for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).== Criticism ==XML and its extensions have regularly been criticized for verbosity and complexity.&lt;ref&gt;Jeff Atwood (2009): [http://www.codinghorror.com/blog/2008/05/xml-the-angle-bracket-tax.html XML: The Angle Bracket Tax]&lt;/ref&gt; Mapping the basic tree model of XML to [[type system]]s of programming languages or databases can be difficult, especially when XML is used for exchanging highly structured data between applications, which was not its primary design goal. Other criticisms attempt to refute the claim that XML is a [[self-describing]] language&lt;ref&gt;Eric Brown (2003): [http://workflow.healthbase.info/monographs/XML_myths_Browne.pdf The Myth of Self-Describing XML]&lt;/ref&gt; (though the XML specification itself makes no such claim).  [[JSON]] and [[YAML]] are frequently proposed as alternatives; both focus on representing structured data, rather than narrative documents.==See also==* [[List of XML markup languages]]* [[Comparison of layout engines (XML)]]* [[Binary XML]]* [[Struxt]] C-style equivalent to XML* [[:Category:XML]]* [[:Category:XML-based standards]]* [[Billion laughs]] (a denial-of-service attack on XML parsers)* [[XML Protocol]]* [[Comparison of data serialization formats]]==References=={{reflist|colwidth=30em}}==Further reading==*Annex A of ISO 8879:1986 (SGML)*{{cite journal |id= {{SSRN|900616}} |author=Lawrence A. Cunningham|title=Language, Deals and Standards: The Future of XML Contracts|journal=Washington University Law Review|year=2005 }}*{{cite journal|last=Bosak |first=Jon |coauthors=Tim Bray |title=XML and the Second-Generation Web|journal=Scientific American|year=1999|month=May}} Online at [http://www.scientificamerican.com/article.cfm?id=xml-and-the-second-genera XML and the Second-Generation Web].*{{cite web|url=http://www.developer.com/xml/article.php/10929_3583081_1|title=Making Mistakes with XML|last=Kelly|first=Sean |authorlink=Sean Kelly|date=February 6, 2006|work=Developer.com|accessdate=2010-10-26}}*{{cite web|url=http://www-128.ibm.com/developerworks/library/x-think38.html|title=Thinking XML: The XML decade|last=Ogbuji|first=Uche|date=14 Nov 2006|work=developerWorks|publisher=[[IBM]]|accessdate=2010-10-26}}*{{cite web|url=http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html|title=Five years later, XML...|last=St. Laurent|first=Simon|date=February 12, 2003|work=O'Reilly XML Blog|publisher=[[O'Reilly Media]]|accessdate=2010-10-26}}*{{cite web|url=http://www.w3.org/2008/02/xml10-pressrelease|title=W3C XML is Ten!|date=12 February 2008|publisher=[[World Wide Web Consortium]]|accessdate=2010-10-26}}*{{cite web|url=http://xml.silmaril.ie/|title=The XML FAQ|date=5 January 2011|publisher=Silmaril|first=Peter [ed]|last=Flynn|location=Cork}}==External links=={{Commons category|XML}}{{Wikibooks}}{{External links|date=November 2010}}&lt;!--PLEASE NOTE: If you wish to add additional external links, please discuss it on the talk page first, since this article is prone to linkfarming.--&gt;*[http://www.w3.org/XML/ W3C XML homepage]*[http://www.w3.org/TR/REC-xml XML 1.0 Specification]*[http://xml.ascc.net/en/utf-8/ercsretro.html Retrospective on Extended Reference Concrete Syntax] by [[Rick Jelliffe]]*[http://www.xml.com/pub/a/w3j/s3.bosak.html XML, Java and the Future of the Web] by [[Jon Bosak]]*[http://xml.gov/ XML.gov]*[http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html XML: Ten year anniversary] by Elliot Kimber*[http://www.itworld.com/xml-fallacies-nlstipsm-080122 23 XML fallacies to watch out for] by Sean McGrath*[http://projects.webappsec.org/XML-Injection XML Injection] - Web Application Security Consortium&lt;!--PLEASE NOTE: If you wish to add additional external links, please discuss it on the talk page first, since this article is prone to linkfarming.--&gt;{{W3C Standards}}{{DEFAULTSORT:Xml}}[[Category:XML| ]][[Category:Markup languages]][[Category:World Wide Web Consortium standards]][[Category:Technical communication]][[Category:Bibliography file formats]][[Category:Computer file formats]][[Category:Open formats]][[Category:Data modeling languages]][[Category:Data serialization formats]][[Category:Application layer protocols]][[Category:Presentation layer protocols]][[af:XML]][[ar:لغة الرقم القابلة للامتداد]][[az:XML]][[bn:এক্সটেনসিভ মার্কআপ ল্যাংগুয়েজ]][[bs:XML]][[bg:XML]][[ca:Extensible Markup Language]][[cs:Extensible Markup Language]][[da:XML]][[de:Extensible Markup Language]][[et:XML]][[el:XML]][[es:Extensible Markup Language]][[eo:XML]][[eu:XML]][[fa:اکس‌ام‌ال]][[fr:Extensible Markup Language]][[ga:XML]][[gl:XML]][[ko:XML]][[hi:क्षमल]][[hr:XML]][[id:Extensible markup language]][[ia:XML]][[is:XML]][[it:XML]][[he:XML]][[lo:XML]][[lv:Valoda XML]][[lt:XML]][[hu:XML]][[mk:XML]][[ml:എക്സ്.എം.എൽ.]][[ms:XML]][[mn:XML]][[nl:Extensible Markup Language]][[ja:Extensible Markup Language]][[no:XML]][[nn:XML]][[pl:XML]][[pt:XML]][[ro:XML]][[ru:XML]][[sq:XML]][[simple:XML]][[sk:XML]][[sl:XML]][[ckb:ئێکس ئێم ئێڵ]][[sr:XML]][[fi:XML]][[sv:XML]][[ta:எக்ஸ்எம்எல்]][[te:XML]][[th:เอกซ์เอ็มแอล]][[tg:XML]][[tr:XML]][[tk:XML]][[uk:XML]][[ur:توسیعی زبان تدوین]][[vi:XML]][[bat-smg:XML]][[zh:XML]]</text></revision></page>
